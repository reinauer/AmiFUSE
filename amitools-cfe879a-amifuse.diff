diff --git a/amitools/vamos/lib/DosLibrary.py b/amitools/vamos/lib/DosLibrary.py
index c4a7b08..f817646 100644
--- a/amitools/vamos/lib/DosLibrary.py
+++ b/amitools/vamos/lib/DosLibrary.py
@@ -24,6 +24,8 @@ from amitools.vamos.libstructs import (
     CLIStruct,
     DosPacketStruct,
     PathStruct,
+    DosListVolumeStruct,
+    DosListAssignStruct,
 )
 from amitools.vamos.error import *
 from amitools.vamos.log import log_dos
@@ -75,6 +77,7 @@ class DosLibrary(LibImpl):
         self.path = []
         self.resident = []
         self.local_vars = {}
+        self.dos_entries = {}
         self.access = AccessStruct(ctx.mem, self.get_struct_def(), base_addr)
         # setup RootNode
         self.root_struct = ctx.alloc.alloc_struct(RootNodeStruct, label="RootNode")
@@ -96,6 +99,74 @@ class DosLibrary(LibImpl):
             ctx.path_mgr, ctx.exec_lib.port_mgr, ctx.alloc, ctx.mem
         )
 
+    # --- Timing ---
+
+    def Delay(self, ctx):
+        # DOS Delay waits d1 ticks (1/50s = 20ms per tick)
+        ticks = ctx.cpu.r_reg(REG_D1)
+        log_dos.info("Delay(%d)", ticks)
+        if ticks > 0:
+            time.sleep(ticks / 50.0)
+        return 0
+
+    def AttemptLockDosList(self, ctx):
+        flags = ctx.cpu.r_reg(REG_D1)
+        if not getattr(self, "_attempt_lock_warned", False):
+            log_dos.info("AttemptLockDosList(flags=0x%x) stub -> dummy success", flags)
+            self._attempt_lock_warned = True
+        dummy = 0x1000
+        # Return a non-zero dummy pointer (must be >1 for some callers)
+        return dummy
+
+    def MakeDosEntry(self, ctx):
+        name_bptr = ctx.cpu.r_reg(REG_D1)
+        entry_type = ctx.cpu.r_reg(REG_D2)
+        try:
+            name = ctx.mem.r_bstr(name_bptr) if name_bptr else ""
+        except Exception:
+            name = ""
+        if name is None or name == "":
+            name = f"vol_{entry_type:x}"
+        struct_def = (
+            DosListAssignStruct if entry_type == 1 else DosListVolumeStruct
+        )
+        mem = ctx.alloc.alloc_struct(struct_def, label=f"DosList({name})")
+        acc = mem.access
+        acc.w_s("dol_Next", 0)
+        acc.w_s("dol_Type", entry_type)
+        acc.w_s("dol_Task", 0)
+        acc.w_s("dol_Lock", 0)
+        if struct_def is DosListVolumeStruct:
+            acc.w_s("dol_LockList", 0)
+            acc.w_s("dol_DiskType", 0)
+        else:
+            acc.w_s("dol_List", 0)
+        name_mem = ctx.alloc.alloc_bstr("DosListName", name)
+        acc.w_s("dol_Name", name_mem.addr)
+        self.dos_entries[mem.addr] = {"mem": mem, "name": name_mem}
+        log_dos.info("MakeDosEntry('%s', type=%d) -> 0x%x", name, entry_type, mem.addr)
+        return mem.addr
+
+    def AddDosEntry(self, ctx):
+        dlist_ptr = ctx.cpu.r_reg(REG_D1)
+        ok = dlist_ptr != 0
+        log_dos.info("AddDosEntry(0x%x) -> %s", dlist_ptr, ok)
+        return self.DOSTRUE if ok else self.DOSFALSE
+
+    def RemDosEntry(self, ctx):
+        dlist_ptr = ctx.cpu.r_reg(REG_D1)
+        log_dos.info("RemDosEntry(0x%x)", dlist_ptr)
+        return self.DOSTRUE
+
+    def FreeDosEntry(self, ctx):
+        dlist_ptr = ctx.cpu.r_reg(REG_D1)
+        entry = self.dos_entries.pop(dlist_ptr, None)
+        if entry:
+            ctx.alloc.free_bstr(entry["name"])
+            ctx.alloc.free_struct(entry["mem"])
+        log_dos.info("FreeDosEntry(0x%x)", dlist_ptr)
+        return 0
+
     def finish_lib(self, ctx):
         # finish file manager
         self.file_mgr.finish()
diff --git a/amitools/vamos/lib/ExecLibrary.py b/amitools/vamos/lib/ExecLibrary.py
index 53d68fc..732612c 100644
--- a/amitools/vamos/lib/ExecLibrary.py
+++ b/amitools/vamos/lib/ExecLibrary.py
@@ -6,6 +6,7 @@ from amitools.vamos.libstructs import (
     ExecLibraryStruct,
     StackSwapStruct,
     IORequestStruct,
+    MsgPortStruct,
     ListStruct,
     NodeStruct,
     NodeType,
@@ -50,6 +51,8 @@ class ExecLibrary(LibImpl):
         self.port_mgr = PortManager(ctx.alloc)
         self.semaphore_mgr = SemaphoreManager(ctx.alloc, ctx.mem)
         self.mem = ctx.mem
+        # simple signal allocator bitmap
+        self._signals = [False] * 32
 
     def set_this_task(self, process):
         self.exec_lib.this_task.aptr = process.this_task.addr
@@ -98,6 +101,28 @@ class ExecLibrary(LibImpl):
         )
         return old_signals
 
+    def AllocSignal(self, ctx):
+        sig = ctx.cpu.r_reg(REG_D0)
+        chosen = -1
+        if sig == 0xFFFFFFFF or sig == -1 or sig >= len(self._signals) or sig < 0:
+            for idx, used in enumerate(self._signals):
+                if not used:
+                    chosen = idx
+                    self._signals[idx] = True
+                    break
+        elif 0 <= sig < len(self._signals) and not self._signals[sig]:
+            self._signals[sig] = True
+            chosen = sig
+        log_exec.info("AllocSignal(%d) -> %d", sig, chosen)
+        return chosen
+
+    def FreeSignal(self, ctx):
+        sig = ctx.cpu.r_reg(REG_D0)
+        if 0 <= sig < len(self._signals):
+            self._signals[sig] = False
+        log_exec.info("FreeSignal(%d)", sig)
+        return 0
+
     def StackSwap(self, ctx):
         stsw_ptr = ctx.cpu.r_reg(REG_A0)
         stsw = AccessStruct(ctx.mem, StackSwapStruct, struct_addr=stsw_ptr)
@@ -296,6 +321,8 @@ class ExecLibrary(LibImpl):
         flags = ctx.cpu.r_reg(REG_D0)
         size = (ctx.cpu.r_reg(REG_D1) + 7) & -8
         thresh = ctx.cpu.r_reg(REG_D2)
+        if size >= 0x100000:
+            print(f"[CreatePool] large size={size} thresh={thresh} flags=0x{flags:x}")
         pool = Pool(self.mem, self.alloc, flags, size, thresh, poolid)
         self._pools[poolid] = pool
         log_exec.info("CreatePool: pool 0x%x" % poolid)
@@ -323,6 +350,14 @@ class ExecLibrary(LibImpl):
         poolid = ctx.cpu.r_reg(REG_A0)
         size = (ctx.cpu.r_reg(REG_D0) + 7) & -8
         mem_ptr = ctx.cpu.r_reg(REG_A1)
+        pc = self.get_callee_pc(ctx)
+        log_exec.info(
+            "FreePooled(call@%06x): pool=0x%x mem=0x%06x size=0x%x",
+            pc,
+            poolid,
+            mem_ptr,
+            size,
+        )
         if poolid in self._pools:
             pool = self._pools[poolid]
             pool.FreePooled(mem_ptr, size)
@@ -355,7 +390,10 @@ class ExecLibrary(LibImpl):
         # label alloc
         pc = self.get_callee_pc(ctx)
         name = "AllocMem(%06x)" % pc
-        mb = self.alloc.alloc_memory(size, label=name)
+        mb = self.alloc.alloc_memory(size, label=name, except_on_failure=False)
+        if mb is None:
+            log_exec.info("AllocMem FAILED: %s size=%d flags=%08x", name, size, flags)
+            return 0
         log_exec.info("AllocMem: %s -> 0x%06x %d bytes" % (mb, mb.addr, size))
         return mb.addr
 
@@ -378,7 +416,48 @@ class ExecLibrary(LibImpl):
         size = ctx.cpu.r_reg(REG_D0)
         flags = ctx.cpu.r_reg(REG_D1)
         name = "AllocVec(@%06x)" % self.get_callee_pc(ctx)
-        mb = self.alloc.alloc_memory(size, label=name)
+        if size >= 0x100000:
+            pc = self.get_callee_pc(ctx)
+            d1 = ctx.cpu.r_reg(REG_D1)
+            d2 = ctx.cpu.r_reg(REG_D2)
+            d3 = ctx.cpu.r_reg(REG_D3)
+            a0 = ctx.cpu.r_reg(REG_A0)
+            a1 = ctx.cpu.r_reg(REG_A1)
+            a2 = ctx.cpu.r_reg(REG_A2)
+            a3 = ctx.cpu.r_reg(REG_A3)
+            sp = ctx.cpu.r_reg(REG_A7)
+            snippet = ctx.mem.r_block(pc, 10)
+            stack_dump = ctx.mem.r_block(sp, 32)
+            print(
+                f"[AllocVec] large size={size} flags=0x{flags:x} pc=0x{pc:x} "
+                f"d1=0x{d1:x} d2=0x{d2:x} d3=0x{d3:x} "
+                f"a0=0x{a0:x} a1=0x{a1:x} a2=0x{a2:x} a3=0x{a3:x} "
+                f"sp=0x{sp:x} stack={stack_dump.hex()} bytes={snippet.hex()}"
+            )
+            # keep last large alloc for host inspection
+            self._last_large_alloc = {
+                "size": int(size),
+                "flags": int(flags),
+                "pc": int(pc),
+                "d1": int(d1),
+                "d2": int(d2),
+                "d3": int(d3),
+                "a0": int(a0),
+                "a1": int(a1),
+                "a2": int(a2),
+                "a3": int(a3),
+                "sp": int(sp),
+                "stack": stack_dump,
+                "snippet": snippet,
+            }
+            if size > 4 * 1024 * 1024:
+                print(f"[AllocVec] clamping large request to 512k for now")
+                size = 512 * 1024
+        mb = self.alloc.alloc_memory(size, label=name, except_on_failure=False)
+        if mb is None:
+            log_exec.info("AllocVec FAILED: %s size=%d flags=%08x", name, size, flags)
+            print(f"[AllocVec] FAILED size={size} flags=0x{flags:x}")
+            return 0
         log_exec.info("AllocVec: %s, flags=%08x", name, flags)
         return mb.addr
 
@@ -413,6 +492,9 @@ class ExecLibrary(LibImpl):
         port_addr = ctx.cpu.r_reg(REG_A0)
         msg_addr = ctx.cpu.r_reg(REG_A1)
         log_exec.info("PutMsg: port=%06x msg=%06x" % (port_addr, msg_addr))
+        if port_addr == 0:
+            print(f"[PutMsg] ignoring null port for msg=0x{msg_addr:x}")
+            return
         has_port = self.port_mgr.has_port(port_addr)
         if not has_port:
             raise VamosInternalError(
@@ -438,7 +520,21 @@ class ExecLibrary(LibImpl):
 
     def CreateMsgPort(self, ctx):
         port = self.port_mgr.create_port("exec_port", None)
+        # initialize msgport fields
+        mp = AccessStruct(ctx.mem, MsgPortStruct, port)
+        ctx.mem.w_block(port, b"\x00" * MsgPortStruct.get_size())
+        mp.w_s("mp_Node.ln_Type", NodeType.NT_MSGPORT)
+        mp.w_s("mp_Flags", 0)
+        mp.w_s("mp_SigBit", 0)
+        mp.w_s("mp_SigTask", self.exec_lib.this_task.aptr)
+        lst_off = MsgPortStruct.sdef.find_field_def_by_name("mp_MsgList").offset
+        lst = AccessStruct(ctx.mem, ListStruct, port + lst_off)
+        lst.w_s("lh_Head", 0)
+        lst.w_s("lh_Tail", 0)
+        lst.w_s("lh_TailPred", 0)
+        lst.w_s("lh_Type", NodeType.NT_MESSAGE)
         log_exec.info("CreateMsgPort: -> port=%06x" % (port))
+        print(f"[CreateMsgPort] -> 0x{port:x}")
         return port
 
     def DeleteMsgPort(self, ctx):
@@ -454,10 +550,17 @@ class ExecLibrary(LibImpl):
         pc = self.get_callee_pc(ctx)
         name = "CreateIORequest(%06x)" % pc
         mb = self.alloc.alloc_memory(size, label=name)
+        ctx.mem.w_block(mb.addr, b"\x00" * size)
+        io = AccessStruct(ctx.mem, IORequestStruct, mb.addr)
+        io.w_s("io_Message.mn_ReplyPort", port)
+        io.w_s("io_Message.mn_Length", size)
+        io.w_s("io_Flags", 0)
+        io.w_s("io_Error", 0)
         log_exec.info(
             "CreateIORequest: (%s,%s,%s) -> 0x%06x %d bytes"
             % (mb, port, size, mb.addr, size)
         )
+        print(f"[CreateIORequest] port=0x{port:x} size={size} -> 0x{mb.addr:x}")
         return mb.addr
 
     def DeleteIORequest(self, ctx):
@@ -477,7 +580,18 @@ class ExecLibrary(LibImpl):
         io_addr = ctx.cpu.r_reg(REG_A1)
         io = AccessStruct(ctx.mem, IORequestStruct, io_addr)
         flags = ctx.cpu.r_reg(REG_D1)
+        raw = ctx.mem.r_block(name_ptr, 32)
         name = ctx.mem.r_cstr(name_ptr)
+        print(
+            f"[OpenDevice] ptr=0x{name_ptr:x} raw={raw[:16].hex()} unit={unit} flags={flags} decoded='{name}'"
+        )
+        # temporary guard: handler sometimes passes garbage; force scsi.device to probe IO path
+        if not name or any(ch < 0x20 or ch > 0x7E for ch in raw[: max(1, len(name))]):
+            log_exec.warning(
+                "OpenDevice: suspicious name bytes=%s -> forcing 'scsi.device'",
+                raw.hex(),
+            )
+            name = "scsi.device"
         addr = self.lib_mgr.open_lib(name)
         io.w_s("io_Device", addr)
         if addr == 0:
@@ -491,6 +605,68 @@ class ExecLibrary(LibImpl):
             )
             return 0
 
+    def _dispatch_begin_io(self, ctx, io_addr):
+        """Helper to call BeginIO on the target device and mark the request done."""
+        io = AccessStruct(ctx.mem, IORequestStruct, io_addr)
+        dev_addr = io.r_s("io_Device")
+        vlib = self.lib_mgr.get_vlib_by_addr(dev_addr)
+        if vlib is None:
+            log_exec.warning("DoIO: missing device for io=0x%06x dev=0x%06x", io_addr, dev_addr)
+            return -1
+        impl = vlib.get_impl()
+        # ensure regs point at the IORequest
+        ctx.cpu.w_reg(REG_A1, io_addr)
+        if hasattr(impl, "BeginIO"):
+            impl.BeginIO(ctx)
+            # flag completion
+            flags = io.r_s("io_Flags") | 1  # IOF_QUICK
+            io.w_s("io_Flags", flags)
+            io.w_s("io_Message.mn_Node.ln_Type", NodeType.NT_REPLYMSG)
+            return io.r_s("io_Error")
+        log_exec.warning("DoIO: device impl missing BeginIO for dev=0x%06x", dev_addr)
+        return -1
+
+    def DoIO(self, ctx):
+        io_addr = ctx.cpu.r_reg(REG_A1)
+        res = self._dispatch_begin_io(ctx, io_addr)
+        log_exec.info("DoIO(io=0x%06x) -> %d", io_addr, res)
+        return res
+
+    def SendIO(self, ctx):
+        io_addr = ctx.cpu.r_reg(REG_A1)
+        res = self._dispatch_begin_io(ctx, io_addr)
+        log_exec.info("SendIO(io=0x%06x) -> %d", io_addr, res)
+        return res
+
+    def CheckIO(self, ctx):
+        io_addr = ctx.cpu.r_reg(REG_A1)
+        io = AccessStruct(ctx.mem, IORequestStruct, io_addr)
+        # synchronous for now
+        log_exec.info("CheckIO(io=0x%06x)", io_addr)
+        return 1 if (io.r_s("io_Flags") & 1) else 0
+
+    def WaitIO(self, ctx):
+        io_addr = ctx.cpu.r_reg(REG_A1)
+        io = AccessStruct(ctx.mem, IORequestStruct, io_addr)
+        log_exec.info("WaitIO(io=0x%06x)", io_addr)
+        return io.r_s("io_Error")
+
+    def Wait(self, ctx):
+        mask = ctx.cpu.r_reg(REG_D0) & 0xFFFFFFFF
+        pending = 0
+        # check all known ports for pending messages and synthesize signals
+        for port_addr in list(self.port_mgr.ports.keys()):
+            try:
+                mp = AccessStruct(self.mem, MsgPortStruct, port_addr)
+                sigbit = mp.r_s("mp_SigBit")
+                if sigbit >= 0 and self.port_mgr.has_msg(port_addr):
+                    pending |= 1 << sigbit
+            except Exception:
+                continue
+        res = pending & mask
+        log_exec.info("Wait(mask=0x%x) -> 0x%x", mask, res)
+        return res
+
     def CloseDevice(self, ctx):
         io_addr = ctx.cpu.r_reg(REG_A1)
         if io_addr != 0:
@@ -501,6 +677,10 @@ class ExecLibrary(LibImpl):
                 self.lib_mgr.close_lib(dev_addr)
                 io.w_s("io_Device", 0)
 
+    # Class variable to track WaitPort state for amifuse integration
+    _waitport_blocked_port = None  # Port address when blocked waiting for message
+    _waitport_blocked_sp = None    # Stack pointer when blocked (has return address)
+
     def WaitPort(self, ctx):
         port_addr = ctx.cpu.r_reg(REG_A0)
         log_exec.info("WaitPort: port=%06x" % (port_addr))
@@ -511,12 +691,22 @@ class ExecLibrary(LibImpl):
             )
         has_msg = self.port_mgr.has_msg(port_addr)
         if not has_msg:
+            # No message pending. Save state for amifuse to restart from.
+            # The return address is on the stack (pushed by JSR before A-line trap).
+            sp = ctx.cpu.r_reg(REG_A7)
+            ExecLibrary._waitport_blocked_port = port_addr
+            ExecLibrary._waitport_blocked_sp = sp
+            # Raise exception to terminate the run
             raise UnsupportedFeatureError(
                 "WaitPort on empty message queue called: Port (%06x)" % port_addr
             )
-        msg_addr = self.port_mgr.get_msg(port_addr)
-        log_exec.info("WaitPort: got message %06x" % (msg_addr))
-        return msg_addr
+        # Clear blocked state since we have a message
+        ExecLibrary._waitport_blocked_port = None
+        ExecLibrary._waitport_blocked_sp = None
+        msg_addr = self.port_mgr.peek_msg(port_addr)
+        log_exec.info("WaitPort: pending message %06x" % (msg_addr))
+        # Return the port address (Exec returns the MsgPort ptr)
+        return port_addr
 
     def AddTail(self, ctx):
         list_addr = ctx.cpu.r_reg(REG_A0)
diff --git a/amitools/vamos/lib/TimerDevice.py b/amitools/vamos/lib/TimerDevice.py
index 24a8d56..d8777f3 100644
--- a/amitools/vamos/lib/TimerDevice.py
+++ b/amitools/vamos/lib/TimerDevice.py
@@ -1,12 +1,45 @@
+import time
 from amitools.vamos.libcore import LibImpl
-from amitools.vamos.machine.regs import REG_A0
+from amitools.vamos.machine.regs import REG_A0, REG_A1
 from amitools.vamos.astructs import AccessStruct
 from amitools.vamos.libstructs import DateStampStruct
+from amitools.vamos.libstructs.exec_ import IORequestStruct
 
 from datetime import datetime
 
+# Timer commands
+TR_ADDREQUEST = 9
+TR_GETSYSTIME = 11
+
 
 class TimerDevice(LibImpl):
+    def BeginIO(self, ctx):
+        """Handle timer IO requests."""
+        io_addr = ctx.cpu.r_reg(REG_A1)
+        io = AccessStruct(ctx.mem, IORequestStruct, io_addr)
+        cmd = io.r_s("io_Command")
+
+        # Clear error
+        io.w_s("io_Error", 0)
+
+        if cmd == TR_ADDREQUEST:
+            # Timer request - read timeval from io_Data area
+            # The timeval is at offset 32 in the timerequest structure
+            # tv_secs at +32, tv_micro at +36
+            tv_secs = ctx.mem.r32(io_addr + 32)
+            tv_micro = ctx.mem.r32(io_addr + 36)
+            delay_secs = tv_secs + tv_micro / 1000000.0
+            # Cap at 1 second max to avoid long hangs, but still provide real delay
+            if delay_secs > 0:
+                time.sleep(min(delay_secs, 1.0))
+        elif cmd == TR_GETSYSTIME:
+            # Return current time
+            now = time.time()
+            ctx.mem.w32(io_addr + 32, int(now))
+            ctx.mem.w32(io_addr + 36, int((now % 1) * 1000000))
+        # Other commands just succeed
+        return 0
+
     def ReadEClock(self, ctx):
         eclockval = ctx.cpu.r_reg(REG_A0)
 
diff --git a/amitools/vamos/lib/lexec/Pool.py b/amitools/vamos/lib/lexec/Pool.py
index cb59d7c..9eda1f4 100644
--- a/amitools/vamos/lib/lexec/Pool.py
+++ b/amitools/vamos/lib/lexec/Pool.py
@@ -51,10 +51,28 @@ class Pool:
 
     def FreePooled(self, mem, size):
         if mem != 0:
+            log_exec.debug(
+                "[Pool] FreePooled attempt mem=0x%06x size=0x%x puddles=%d",
+                mem,
+                size,
+                len(self.puddles),
+            )
             for puddle in self.puddles:
                 if puddle.contains(mem, size):
                     puddle.FreePooled(mem, size)
+                    log_exec.debug(
+                        "[Pool] FreePooled ok mem=0x%06x size=0x%x in %s",
+                        mem,
+                        size,
+                        puddle,
+                    )
                     return
+            ranges = [
+                "0x%06x-0x%06x" % (p.mem_obj.addr, p.mem_obj.addr + p.size)
+                for p in self.puddles
+                if getattr(p, "mem_obj", None) is not None
+            ]
             raise VamosInternalError(
-                "FreePooled: invalid memory, not in any puddle : ptr=%06x" % mem
+                "FreePooled: invalid memory, not in any puddle : ptr=%06x size=0x%x puddles=%s"
+                % (mem, size, ranges)
             )
diff --git a/amitools/vamos/lib/lexec/PortManager.py b/amitools/vamos/lib/lexec/PortManager.py
index 51ef4f6..cb982ae 100644
--- a/amitools/vamos/lib/lexec/PortManager.py
+++ b/amitools/vamos/lib/lexec/PortManager.py
@@ -27,6 +27,12 @@ class Port:
         else:
             self.queue.append(msg_addr)
 
+    def peek_msg(self):
+        if self.queue is not None and len(self.queue) > 0:
+            return self.queue[0]
+        else:
+            return None
+
     def has_msg(self):
         if self.queue is not None:
             return len(self.queue) > 0
@@ -88,3 +94,7 @@ class PortManager:
     def get_msg(self, port_addr):
         port = self.ports[port_addr]
         return port.get_msg()
+
+    def peek_msg(self, port_addr):
+        port = self.ports[port_addr]
+        return port.peek_msg()
diff --git a/amitools/vamos/lib/lexec/Puddle.py b/amitools/vamos/lib/lexec/Puddle.py
index d00d88a..3b52ef7 100644
--- a/amitools/vamos/lib/lexec/Puddle.py
+++ b/amitools/vamos/lib/lexec/Puddle.py
@@ -10,6 +10,8 @@ class Puddle:
         self.label_mgr = label_mgr
         self.mem = mem
         self.size = size
+        if size >= 0x100000:
+            print(f"[Puddle] large size={size} label={name}")
         self.mem_obj = self.alloc.alloc_memory(size, label=name)
         self.chunks = MemoryAlloc(self.mem, self.mem_obj.addr, size, label_mgr)
 
diff --git a/amitools/vamos/libmgr/setup.py b/amitools/vamos/libmgr/setup.py
index 3aaf28d..44c02f4 100644
--- a/amitools/vamos/libmgr/setup.py
+++ b/amitools/vamos/libmgr/setup.py
@@ -104,7 +104,8 @@ class SetupLibManager(object):
     def cur_task_callback(self, task):
         log_libmgr.info("current task: %s", task)
         if task:
-            proc = task.process
-            self.exec_ctx.set_process(proc)
-            self.exec_impl.set_this_task(proc)
-            self.dos_ctx.set_process(proc)
+            proc = getattr(task, 'process', None)
+            if proc is not None:
+                self.exec_ctx.set_process(proc)
+                self.exec_impl.set_this_task(proc)
+                self.dos_ctx.set_process(proc)
\ No newline at end of file
diff --git a/amitools/vamos/libstructs/exec_.py b/amitools/vamos/libstructs/exec_.py
index 6ab47ac..71cd979 100644
--- a/amitools/vamos/libstructs/exec_.py
+++ b/amitools/vamos/libstructs/exec_.py
@@ -371,7 +371,7 @@ class IORequestStruct(AmigaStruct):
     _format = [
         (MessageStruct, "io_Message"),
         (APTR(DeviceStruct), "io_Device"),
-        (UnitStruct, "io_Unit"),
+        (APTR(UnitStruct), "io_Unit"),
         (UWORD, "io_Command"),
         (UBYTE, "io_Flags"),
         (BYTE, "io_Error"),
